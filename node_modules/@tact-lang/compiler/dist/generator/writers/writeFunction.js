"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeGetter = exports.writeReceiver = exports.writeFunction = exports.writeStatement = exports.unwrapExternal = exports.writeCastedExpression = void 0;
const ton_core_1 = require("ton-core");
const config_1 = require("../../config");
const resolveDescriptors_1 = require("../../types/resolveDescriptors");
const resolveExpression_1 = require("../../types/resolveExpression");
const utils_1 = require("../../utils/utils");
const resolveFuncPrimitive_1 = require("./resolveFuncPrimitive");
const resolveFuncType_1 = require("./resolveFuncType");
const resolveFuncTypeUnpack_1 = require("./resolveFuncTypeUnpack");
const id_1 = require("./id");
const writeExpression_1 = require("./writeExpression");
const cast_1 = require("./cast");
const resolveFuncTupledType_1 = require("./resolveFuncTupledType");
function writeCastedExpression(expression, to, ctx) {
    let expr = (0, resolveExpression_1.getExpType)(ctx.ctx, expression);
    return (0, cast_1.cast)(expr, to, (0, writeExpression_1.writeExpression)(expression, ctx), ctx); // Cast for nullable
}
exports.writeCastedExpression = writeCastedExpression;
function unwrapExternal(targetName, sourceName, type, ctx) {
    if (type.kind === 'ref') {
        let t = (0, resolveDescriptors_1.getType)(ctx.ctx, type.name);
        if (t.kind === 'struct') {
            if (type.optional) {
                ctx.used(`__gen_${t.name}_from_opt_tuple`);
                ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = __gen_${t.name}_from_opt_tuple(${sourceName});`);
            }
            else {
                ctx.used(`__gen_${t.name}_from_tuple`);
                ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = __gen_${t.name}_from_tuple(${sourceName});`);
            }
            return;
        }
    }
    ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = ${sourceName};`);
}
exports.unwrapExternal = unwrapExternal;
function writeStatement(f, self, returns, ctx) {
    if (f.kind === 'statement_return') {
        if (f.expression) {
            // Format expression
            let result = writeCastedExpression(f.expression, returns, ctx);
            // Return
            if (self) {
                ctx.append(`return (${self}, ${result});`);
            }
            else {
                ctx.append(`return ${result};`);
            }
        }
        else {
            if (self) {
                ctx.append(`return (${self}, ());`);
            }
            else {
                ctx.append(`return;`);
            }
        }
        return;
    }
    else if (f.kind === 'statement_let') {
        // Contract/struct case
        let t = (0, resolveDescriptors_1.resolveTypeRef)(ctx.ctx, f.type);
        if (t.kind === 'ref') {
            let tt = (0, resolveDescriptors_1.getType)(ctx.ctx, t.name);
            if (tt.kind === 'contract' || tt.kind === 'struct') {
                if (t.optional) {
                    ctx.append(`tuple ${(0, id_1.id)(f.name)} = ${writeCastedExpression(f.expression, t, ctx)};`);
                }
                else {
                    ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, (0, id_1.id)(f.name), ctx)} = ${writeCastedExpression(f.expression, t, ctx)};`);
                }
                return;
            }
        }
        ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(t, ctx)} ${(0, id_1.id)(f.name)} = ${writeCastedExpression(f.expression, t, ctx)};`);
        return;
    }
    else if (f.kind === 'statement_assign') {
        // Prepare lvalue
        let path = f.path.map((v, i) => (i === 0) ? (0, id_1.id)(v.name) : v.name).join(`'`);
        // Contract/struct case
        let t = (0, resolveExpression_1.getExpType)(ctx.ctx, f.path[f.path.length - 1]);
        if (t.kind === 'ref') {
            let tt = (0, resolveDescriptors_1.getType)(ctx.ctx, t.name);
            if (tt.kind === 'contract' || tt.kind === 'struct') {
                ctx.append(`${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, `${path}`, ctx)} = ${writeCastedExpression(f.expression, t, ctx)};`);
                return;
            }
        }
        ctx.append(`${path} = ${writeCastedExpression(f.expression, t, ctx)};`);
        return;
    }
    else if (f.kind === 'statement_condition') {
        writeCondition(f, self, false, returns, ctx);
        return;
    }
    else if (f.kind === 'statement_expression') {
        let exp = (0, writeExpression_1.writeExpression)(f.expression, ctx);
        ctx.append(`${exp};`);
        return;
    }
    else if (f.kind === 'statement_while') {
        ctx.append(`while (${(0, writeExpression_1.writeExpression)(f.condition, ctx)}) {`);
        ctx.inIndent(() => {
            for (let s of f.statements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`}`);
        return;
    }
    else if (f.kind === 'statement_until') {
        ctx.append(`do {`);
        ctx.inIndent(() => {
            for (let s of f.statements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`} until (${(0, writeExpression_1.writeExpression)(f.condition, ctx)});`);
        return;
    }
    else if (f.kind === 'statement_repeat') {
        ctx.append(`repeat (${(0, writeExpression_1.writeExpression)(f.condition, ctx)}) {`);
        ctx.inIndent(() => {
            for (let s of f.statements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`}`);
        return;
    }
    throw Error('Unknown statement kind');
}
exports.writeStatement = writeStatement;
function writeCondition(f, self, elseif, returns, ctx) {
    ctx.append(`${(elseif ? '} else' : '')}if (${(0, writeExpression_1.writeExpression)(f.expression, ctx)}) {`);
    ctx.inIndent(() => {
        for (let s of f.trueStatements) {
            writeStatement(s, self, returns, ctx);
        }
    });
    if (f.falseStatements.length > 0) {
        ctx.append(`} else {`);
        ctx.inIndent(() => {
            for (let s of f.falseStatements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`}`);
    }
    else if (f.elseif) {
        writeCondition(f.elseif, self, true, returns, ctx);
    }
    else {
        ctx.append(`}`);
    }
}
function writeFunction(f, ctx) {
    // Do not write native functions
    if (f.ast.kind === 'def_native_function') {
        return;
    }
    const fd = f.ast;
    // Resolve self
    let self = f.self ? (0, resolveDescriptors_1.getType)(ctx.ctx, f.self) : null;
    // Write function header
    let returns = (0, resolveFuncType_1.resolveFuncType)(f.returns, ctx);
    let returnsStr;
    if (self && f.isMutating) {
        if (f.returns.kind !== 'void') {
            returns = `(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}, ${returns})`;
        }
        else {
            returns = `(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}, ())`;
        }
        returnsStr = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx);
    }
    // Resolve function descriptor
    let name = (self ? '__gen_' + self.name + '_' : '') + f.name;
    let modifier = (0, config_1.enabledInline)(ctx.ctx) ? 'impure inline' : 'impure inline_ref';
    let args = [];
    if (self) {
        args.push((0, resolveFuncType_1.resolveFuncType)(self, ctx) + ' ' + (0, id_1.id)('self'));
    }
    for (let a of f.args) {
        args.push((0, resolveFuncType_1.resolveFuncType)(a.type, ctx) + ' ' + (0, id_1.id)(a.name));
    }
    // Write function body
    ctx.fun(name, () => {
        ctx.append(`${returns} ${(0, id_1.fn)(name)}(${args.join(', ')}) ${modifier} {`);
        ctx.inIndent(() => {
            // Unpack self
            if (self) {
                ctx.append(`var (${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx)}) = ${(0, id_1.id)('self')};`);
            }
            for (let a of fd.args) {
                if (!(0, resolveFuncPrimitive_1.resolveFuncPrimitive)((0, resolveDescriptors_1.resolveTypeRef)(ctx.ctx, a.type), ctx)) {
                    ctx.append(`var (${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)((0, resolveDescriptors_1.resolveTypeRef)(ctx.ctx, a.type), (0, id_1.id)(a.name), ctx)}) = ${(0, id_1.id)(a.name)};`);
                }
            }
            // Process statements
            for (let s of fd.statements) {
                writeStatement(s, returnsStr, f.returns, ctx);
            }
            // Auto append return
            if (f.self && (f.returns.kind === 'void') && f.isMutating) {
                if (fd.statements.length === 0 || fd.statements[fd.statements.length - 1].kind !== 'statement_return') {
                    ctx.append(`return (${returnsStr}, ());`);
                }
            }
        });
        ctx.append(`}`);
    });
}
exports.writeFunction = writeFunction;
function writeReceiver(self, f, ctx) {
    const selector = f.selector;
    const modifier = 'impure inline'; // enabledInline(ctx.ctx) ? 'impure inline' : 'impure';
    // Binary receiver
    if (selector.kind === 'internal-binary') {
        ctx.fun(`__gen_${self.name}_receive_${selector.type}`, () => {
            let selfRes = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx);
            ctx.append(`((${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}), ()) ${(0, id_1.fn)(`__gen_${self.name}_receive_${selector.type}`)}(${[(0, resolveFuncType_1.resolveFuncType)(self, ctx) + ' ' + (0, id_1.id)('self'), (0, resolveFuncType_1.resolveFuncType)(selector.type, ctx) + ' ' + (0, id_1.id)(selector.name)].join(', ')}) ${modifier} {`);
            ctx.inIndent(() => {
                ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx)} = ${(0, id_1.id)('self')};`);
                ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(selector.type, (0, id_1.id)(selector.name), ctx)} = ${(0, id_1.id)(selector.name)};`);
                for (let s of f.ast.statements) {
                    writeStatement(s, selfRes, null, ctx);
                }
                if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                    ctx.append(`return (${selfRes}, ());`);
                }
            });
            ctx.append(`}`);
        });
        return;
    }
    // Empty receiver
    if (selector.kind === 'internal-empty') {
        ctx.fun(`__gen_${self.name}_receive`, () => {
            let selfRes = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx);
            ctx.append(`((${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}), ()) ${(0, id_1.fn)(`__gen_${self.name}_receive`)}(${((0, resolveFuncType_1.resolveFuncType)(self, ctx) + ' ' + (0, id_1.id)('self'))}) ${modifier} {`);
            ctx.inIndent(() => {
                ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx)} = ${(0, id_1.id)('self')};`);
                for (let s of f.ast.statements) {
                    writeStatement(s, selfRes, null, ctx);
                }
                if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                    ctx.append(`return (${selfRes}, ());`);
                }
            });
            ctx.append(`}`);
        });
    }
    // Comment receiver
    if (selector.kind === 'internal-comment') {
        let hash = (0, ton_core_1.beginCell)()
            .storeUint(0, 32)
            .storeBuffer(Buffer.from(selector.comment, 'utf8'))
            .endCell()
            .hash()
            .toString('hex', 0, 64);
        ctx.fun(`__gen_${self.name}_receive_comment_${hash}`, () => {
            let selfRes = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx);
            ctx.append(`(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}, ()) ${(0, id_1.fn)(`__gen_${self.name}_receive_comment_${hash}`)}(${((0, resolveFuncType_1.resolveFuncType)(self, ctx) + ' ' + (0, id_1.id)('self'))}) ${modifier} {`);
            ctx.inIndent(() => {
                ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx)} = ${(0, id_1.id)('self')};`);
                for (let s of f.ast.statements) {
                    writeStatement(s, selfRes, null, ctx);
                }
                if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                    ctx.append(`return (${selfRes}, ());`);
                }
            });
            ctx.append(`}`);
        });
    }
    // Fallback
    if (selector.kind === 'internal-comment-fallback') {
        ctx.fun(`__gen_${self.name}_receive_comment`, () => {
            let selfRes = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx);
            ctx.append(`(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}, ()) ${(0, id_1.fn)(`__gen_${self.name}_receive_comment`)}(${([(0, resolveFuncType_1.resolveFuncType)(self, ctx) + ' ' + (0, id_1.id)('self'), 'slice ' + (0, id_1.id)(selector.name)]).join(', ')}) ${modifier} {`);
            ctx.inIndent(() => {
                ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx)} = ${(0, id_1.id)('self')};`);
                for (let s of f.ast.statements) {
                    writeStatement(s, selfRes, null, ctx);
                }
                if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                    ctx.append(`return (${selfRes}, ());`);
                }
            });
            ctx.append(`}`);
        });
    }
    // Fallback
    if (selector.kind === 'internal-fallback') {
        ctx.fun(`__gen_${self.name}_receive_fallback`, () => {
            let selfRes = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx);
            ctx.append(`(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}, ()) ${(0, id_1.fn)(`__gen_${self.name}_receive_fallback`)}(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)} ${(0, id_1.id)('self')}, slice ${(0, id_1.id)(selector.name)}) ${modifier} {`);
            ctx.inIndent(() => {
                ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx)} = ${(0, id_1.id)('self')};`);
                for (let s of f.ast.statements) {
                    writeStatement(s, selfRes, null, ctx);
                }
                if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                    ctx.append(`return (${selfRes}, ());`);
                }
            });
            ctx.append(`}`);
        });
    }
    // Bounced
    if (selector.kind === 'internal-bounce') {
        ctx.fun(`__gen_${self.name}_receive_bounced`, () => {
            let selfRes = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx);
            ctx.append(`(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}, ()) ${(0, id_1.fn)(`__gen_${self.name}_receive_bounced`)}(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)} ${(0, id_1.id)('self')}, slice ${(0, id_1.id)(selector.name)}) ${modifier} {`);
            ctx.inIndent(() => {
                ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx)} = ${(0, id_1.id)('self')};`);
                for (let s of f.ast.statements) {
                    writeStatement(s, selfRes, null, ctx);
                }
                if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                    ctx.append(`return (${selfRes}, ());`);
                }
            });
            ctx.append(`}`);
        });
    }
}
exports.writeReceiver = writeReceiver;
function writeGetter(f, ctx) {
    ctx.fun(`__gen_get_${f.name}`, () => {
        // Render tensors
        const self = f.self ? (0, resolveDescriptors_1.getType)(ctx.ctx, f.self) : null;
        if (!self) {
            throw new Error(`No self type for getter ${f.name}`); // Impossible
        }
        ctx.append(`_ ${(0, id_1.fn)(`__gen_get_${f.name}`)}(${f.args.map((v) => (0, resolveFuncTupledType_1.resolveFuncTupledType)(v.type, ctx) + ' ' + (0, id_1.id)('$' + v.name)).join(', ')}) method_id(${(0, utils_1.getMethodId)(f.name)}) {`);
        ctx.inIndent(() => {
            // Unpack arguments
            for (let arg of f.args) {
                unwrapExternal((0, id_1.id)(arg.name), (0, id_1.id)('$' + arg.name), arg.type, ctx);
            }
            // Load contract state
            ctx.used(`__gen_load_${self.name}`);
            ctx.append(`var self = __gen_load_${self.name}();`);
            // Execute get method
            ctx.used(`__gen_${self.name}_${f.name}`);
            ctx.append(`var res = ${(0, id_1.fn)(`__gen_${self.name}_${f.name}`)}(${['self', ...f.args.map((v) => (0, id_1.id)(v.name))].join(', ')});`);
            // Pack if needed
            if (f.returns.kind === 'ref') {
                let t = (0, resolveDescriptors_1.getType)(ctx.ctx, f.returns.name);
                if (t.kind === 'struct') {
                    if (f.returns.optional) {
                        ctx.used(`__gen_${t.name}_opt_to_external`);
                        ctx.append(`return __gen_${t.name}_opt_to_external(res);`);
                    }
                    else {
                        ctx.used(`__gen_${t.name}_to_external`);
                        ctx.append(`return __gen_${t.name}_to_external(res);`);
                    }
                    return;
                }
            }
            // Return restult
            ctx.append(`return res;`);
        });
        ctx.append(`}`);
    });
}
exports.writeGetter = writeGetter;
