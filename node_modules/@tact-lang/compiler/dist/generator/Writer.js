"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WriterContext = void 0;
const config_1 = require("../config");
const utils_1 = require("../utils/utils");
const Writer_1 = require("../utils/Writer");
class WriterContext {
    ctx;
    #functions = new Map();
    #functionsRendering = new Set();
    #pendingWriter = null;
    #pendingDepends = null;
    #pendingName = null;
    #nextId = 0;
    #headers = [];
    #rendered = new Set();
    constructor(ctx) {
        this.ctx = ctx;
    }
    allocateNextRandomName() {
        return `__gen_internal_${this.#nextId++}`;
    }
    clone() {
        let res = new WriterContext(this.ctx);
        res.#functions = new Map(this.#functions);
        res.#nextId = this.#nextId;
        res.#headers = [...this.#headers];
        res.#rendered = new Set(this.#rendered);
        return res;
    }
    //
    // Rendering
    //
    render(debug = false) {
        // Check dependencies
        let missing = new Map();
        for (let f of this.#functions.values()) {
            for (let d of f.depends) {
                if (!this.#functions.has(d)) {
                    if (!missing.has(d)) {
                        missing.set(d, [f.name]);
                    }
                    else {
                        missing.set(d, [...missing.get(d), f.name]);
                    }
                }
            }
        }
        if (missing.size > 0) {
            throw new Error(`Functions ${Array.from(missing.keys()).map((v) => `"${v}"`).join(', ')} wasn't rendered`);
        }
        // All functions
        let all = Array.from(this.#functions.values());
        // Remove unused
        if (!debug) {
            let used = new Set();
            let visit = (name) => {
                used.add(name);
                let f = this.#functions.get(name);
                for (let d of f.depends) {
                    visit(d);
                }
            };
            visit('$main');
            all = all.filter((v) => used.has(v.name));
        }
        // Sort functions
        let sorted = (0, utils_1.topologicalSort)(all, (f) => Array.from(f.depends).map((v) => this.#functions.get(v)));
        // Render
        let res = '';
        for (let h of this.#headers) {
            if (res !== '') {
                res += '\n';
            }
            res += h;
        }
        for (let f of sorted) {
            if (res !== '') {
                res += '\n\n';
            }
            res += f.code;
        }
        return res;
    }
    //
    // Declaration
    //
    fun(name, handler) {
        //
        // Duplicates check
        //
        if (this.#functions.has(name)) {
            throw new Error(`Function ${name} already defined`); // Should not happen
        }
        if (this.#functionsRendering.has(name)) {
            throw new Error(`Function ${name} already rendering`); // Should not happen
        }
        //
        // Nesting check
        //
        if (!!this.#pendingWriter || !!this.#pendingDepends) {
            let w = this.#pendingWriter;
            let d = this.#pendingDepends;
            let n = this.#pendingName;
            this.#pendingDepends = null;
            this.#pendingWriter = null;
            this.#pendingName = null;
            this.fun(name, handler);
            this.#pendingDepends = d;
            this.#pendingWriter = w;
            this.#pendingName = n;
            return;
        }
        // Write function
        this.#functionsRendering.add(name);
        this.#pendingWriter = new Writer_1.Writer();
        this.#pendingDepends = new Set();
        this.#pendingName = name;
        handler();
        let code = this.#pendingWriter.end();
        let depends = this.#pendingDepends;
        this.#pendingDepends = null;
        this.#pendingWriter = null;
        this.#pendingName = null;
        this.#functionsRendering.delete(name);
        this.#functions.set(name, { name, code, depends });
    }
    used(name) {
        if (this.#pendingName !== name) {
            this.#pendingDepends.add(name);
        }
        return name;
    }
    currentContext() {
        return this.#pendingName;
    }
    //
    // Writers
    //
    inIndent = (handler) => {
        this.#pendingWriter.inIndent(handler);
    };
    append(src = '') {
        this.#pendingWriter.append(src);
    }
    write(src = '') {
        this.#pendingWriter.write(src);
    }
    debug(id) {
        if ((0, config_1.enabledDebug)(this.ctx)) {
            if (typeof id === 'string') {
                this.used('__tact_debug_str');
                this.append(`__tact_debug_str("${id}");`);
            }
            else {
                this.used('__tact_debug');
                let v = (id === undefined || id === null) ? (this.#nextId++) : id;
                this.append(`__tact_debug(${v});`);
            }
        }
    }
    //
    // Headers
    //
    header(src) {
        this.#headers.push(src);
    }
    //
    // Utils
    //
    isRendered(key) {
        return this.#rendered.has(key);
    }
    markRendered(key) {
        if (this.#rendered.has(key)) {
            throw new Error(`Key ${key} already rendered`);
        }
        this.#rendered.add(key);
    }
}
exports.WriterContext = WriterContext;
