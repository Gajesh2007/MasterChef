"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileBindings = exports.compileProjects = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const writeTypescript_1 = require("./bindings/writeTypescript");
const parseConfig_1 = require("./config/parseConfig");
const build_1 = require("./pipeline/build");
async function compileProjects(configPath, projectNames = []) {
    // Load config
    let resolvedPath = path_1.default.resolve(configPath);
    let rootPath = path_1.default.dirname(resolvedPath);
    let config;
    if (!fs_1.default.existsSync(resolvedPath)) {
        console.warn('Unable to find config file at ' + resolvedPath);
        return;
    }
    try {
        config = (0, parseConfig_1.parseConfig)(fs_1.default.readFileSync(resolvedPath, 'utf8'));
    }
    catch (e) {
        console.log(e);
        console.warn('Unable to parse config file at ' + resolvedPath);
        return;
    }
    // Resolve projects
    let projects = config.projects;
    if (projectNames.length > 0) {
        // Check that all proejct names are valid
        for (let pp of projectNames) {
            if (!projects.find((v) => v.name === pp)) {
                console.warn('Unable to find project ' + pp);
                return;
            }
        }
        // Filter by names
        projects = projects.filter((v) => projectNames.includes(v.name));
    }
    if (projects.length === 0) {
        console.warn('No projects to compile');
        return;
    }
    // Compile projects
    for (let project of projects) {
        console.log('ðŸ’¼ Compiling project ' + project.name + '...');
        await (0, build_1.build)(project, rootPath);
    }
}
exports.compileProjects = compileProjects;
async function compileBindings(language, abiPath, outputPath) {
    if (language !== 'typescript') {
        console.warn('Unsupported language: ' + language);
        return;
    }
    let abi = JSON.parse(fs_1.default.readFileSync(abiPath, 'utf-8'));
    let output = (0, writeTypescript_1.writeTypescript)(abi);
    fs_1.default.writeFileSync(outputPath, output, 'utf-8');
}
exports.compileBindings = compileBindings;
