"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromBoc = exports.fromCode = exports.decompileMethodsMap = exports.decompile = exports.setCodepage = void 0;
const ton_core_1 = require("ton-core");
const cp0_generated_1 = require("./codepages/cp0.generated");
const knownMethods_1 = require("./consts/knownMethods");
const isDebug_1 = require("./utils/isDebug");
let codepage = cp0_generated_1.CP0Auto;
function setCodepage(cp) {
    codepage = cp;
}
exports.setCodepage = setCodepage;
function decompile(slice, indent) {
    let result = '';
    const append = (txt) => {
        if (txt instanceof ton_core_1.Cell) {
            result += txt.toString(' '.repeat(indent || 0));
            return;
        }
        if (indent) {
            for (let i = 0; i < indent; i++)
                result += ' ';
        }
        result += txt + '\n';
    };
    let opCode = '';
    while (slice.remainingBits > 0) {
        let opCodePart = slice.loadBit();
        opCode += opCodePart ? '1' : '0';
        let matches = codepage.find(opCode);
        if (matches.length > 1) {
            continue;
        }
        if (matches.length == 1 && opCode.length !== matches[0].length) {
            continue;
        }
        if (matches.length == 0) {
            let fullCell = (0, ton_core_1.beginCell)();
            for (let bit of Array.from(opCode).map(a => a == '0' ? false : true)) {
                fullCell.storeBit(bit);
            }
            fullCell.storeSlice(slice);
            append(fullCell.asCell());
            continue;
        }
        let op = codepage.getOp(opCode);
        opCode = '';
        if (typeof op === 'string') {
            append(op);
        }
        else if (typeof op === 'function') {
            let opTxt = op(slice, indent || 0);
            append(opTxt);
        }
        if (slice.remainingBits === 0 && slice.remainingRefs > 0) {
            slice = slice.loadRef().beginParse();
        }
    }
    return result;
}
exports.decompile = decompile;
function createSliceValue() {
    return {
        serialize: (src, builder) => {
            builder.storeSlice(src);
        },
        parse: (src) => {
            return src;
        }
    };
}
function decompileMethodsMap(slice, keyLen, indent) {
    var _a;
    let methodsMap = slice.loadDictDirect(ton_core_1.Dictionary.Keys.Int(keyLen), createSliceValue());
    let methodsMapDecompiled = new Map();
    for (let [key, cs] of methodsMap) {
        try {
            methodsMapDecompiled.set(key, decompile(cs, (indent || 0) + 4));
        }
        catch (e) {
            (0, isDebug_1._isDebug)() && console.error(e);
            methodsMapDecompiled.set(key, cs.asCell().toString(' '.repeat((indent || 0) + 4)));
        }
    }
    let result = '';
    const append = (txt) => {
        if (indent) {
            for (let i = 0; i < indent; i++)
                result += ' ';
        }
        result += txt + '\n';
    };
    append('(:methods');
    indent = (indent || 0) + 2;
    for (let [methodId, code] of methodsMapDecompiled) {
        append(`${(_a = knownMethods_1.KnownMethods[methodId]) !== null && _a !== void 0 ? _a : methodId}: \n${code}`);
    }
    result = result.slice(0, -1); // remove trailing newline
    indent -= 2;
    append(')');
    result = result.slice(0, -1); // remove trailing newline
    return result;
}
exports.decompileMethodsMap = decompileMethodsMap;
function fromCode(cell) {
    let slice = cell.beginParse();
    let header = slice.loadUint(16);
    if (header !== 0xff00) {
        throw new Error('unsupported codepage');
    }
    let result = 'SETCP0\n';
    result += decompile(slice);
    return result;
}
exports.fromCode = fromCode;
function fromBoc(boc) {
    let cell = ton_core_1.Cell.fromBoc(boc)[0];
    return fromCode(cell);
}
exports.fromBoc = fromBoc;
//# sourceMappingURL=disassembler.js.map