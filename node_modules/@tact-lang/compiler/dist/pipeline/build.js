"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const ton_core_1 = require("ton-core");
const disassembler_1 = require("tvm-disassembler/dist/disassembler");
const writeTypescript_1 = require("../bindings/writeTypescript");
const context_1 = require("../context");
const funcCompile_1 = require("../func/funcCompile");
const writeReport_1 = require("../generator/writeReport");
const packageCode_1 = require("../packaging/packageCode");
const resolveABITypeRef_1 = require("../types/resolveABITypeRef");
const resolveDescriptors_1 = require("../types/resolveDescriptors");
const compile_1 = require("./compile");
const precompile_1 = require("./precompile");
const version = require('../../package.json').version;
async function build(project, rootPath) {
    // Configure context
    let ctx = new context_1.CompilerContext({ shared: {} });
    if (project.experimental && project.experimental.inline) {
        console.warn('   > ðŸ‘€ Enabling inline');
        ctx = (0, context_1.enable)(ctx, 'inline');
    }
    if (project.parameters && project.parameters.debug) {
        console.warn('   > ðŸ‘€ Enabling debug');
        ctx = (0, context_1.enable)(ctx, 'debug');
    }
    // Precompile
    try {
        ctx = (0, precompile_1.precompile)(ctx, rootPath, project.path);
    }
    catch (e) {
        console.warn('Tact compilation failed');
        console.log(e);
        return false;
    }
    // Resolve and create output directory
    let outputPath = path_1.default.resolve(rootPath, project.output);
    if (!fs_1.default.existsSync(outputPath)) {
        fs_1.default.mkdirSync(outputPath);
    }
    // Compile contracts
    let ok = true;
    let built = {};
    for (let contract of (0, resolveDescriptors_1.getContracts)(ctx)) {
        let pathAbi = path_1.default.resolve(outputPath, project.name + '_' + contract + ".abi");
        let pathCodeFc = path_1.default.resolve(outputPath, project.name + '_' + contract + ".code.fc");
        let pathCodeBoc = path_1.default.resolve(outputPath, project.name + '_' + contract + ".code.boc");
        let pathCodeFif = path_1.default.resolve(outputPath, project.name + '_' + contract + ".code.fif");
        let pathCodeFifDec = path_1.default.resolve(outputPath, project.name + '_' + contract + ".code.rev.fif");
        // Compiling contract to func
        console.log('   > ' + contract + ': tact compiler');
        let abi;
        let codeFunc;
        try {
            let res = await (0, compile_1.compile)(ctx, contract);
            fs_1.default.writeFileSync(pathCodeFc, res.output.output, 'utf-8');
            fs_1.default.writeFileSync(pathAbi, res.output.abi, 'utf-8');
            abi = res.output.abi;
            codeFunc = res.output.output;
        }
        catch (e) {
            console.warn('Tact compilation failed');
            console.warn(e);
            ok = false;
            continue;
        }
        // Compiling contract to TVM
        console.log('   > ' + contract + ': func compiler');
        let codeBoc;
        let codeFift;
        try {
            let c = await (0, funcCompile_1.funcCompile)(pathCodeFc);
            if (!c.ok) {
                console.warn(c.log);
                ok = false;
                continue;
            }
            fs_1.default.writeFileSync(pathCodeFif, c.fift, 'utf-8');
            fs_1.default.writeFileSync(pathCodeBoc, c.output);
            codeFift = c.fift;
            codeBoc = c.output;
        }
        catch (e) {
            console.warn('FunC compiler crashed');
            console.warn(e);
            ok = false;
            continue;
        }
        // Fift decompiler for generated code debug
        console.log('   > ' + contract + ': fift decompiler');
        let codeFiftDecompiled;
        try {
            codeFiftDecompiled = (0, disassembler_1.fromBoc)(codeBoc);
            fs_1.default.writeFileSync(pathCodeFifDec, codeFiftDecompiled, 'utf-8');
        }
        catch (e) {
            console.warn('Fift decompiler crashed');
            console.warn(e);
            ok = false;
            continue;
        }
        // Add to built map
        built[contract] = {
            codeFunc,
            codeBoc,
            codeFift,
            codeFiftDecompiled,
            abi
        };
    }
    if (!ok) {
        console.log('ðŸ’¥ Compilation failed. Skipping packaging');
        return false;
    }
    // Package
    console.log('   > Packaging');
    let contracts = project.contracts || (0, resolveDescriptors_1.getContracts)(ctx);
    let packages = [];
    for (let contract of contracts) {
        console.log('   > ' + contract);
        let artifacts = built[contract];
        if (!artifacts) {
            console.warn('   > ' + contract + ': no artifacts found');
            return false;
        }
        // System cell
        const depends = ton_core_1.Dictionary.empty(ton_core_1.Dictionary.Keys.Uint(16), ton_core_1.Dictionary.Values.Cell());
        const ct = (0, resolveDescriptors_1.getType)(ctx, contract);
        depends.set(ct.uid, ton_core_1.Cell.fromBoc(built[ct.name].codeBoc)[0]); // Mine
        for (let c of ct.dependsOn) {
            let cd = built[c.name];
            if (!cd) {
                console.warn('   > ' + cd + ': no artifacts found');
                return false;
            }
            depends.set(c.uid, ton_core_1.Cell.fromBoc(cd.codeBoc)[0]);
        }
        const systemCell = (0, ton_core_1.beginCell)().storeDict(depends).endCell();
        // Package
        let pkg = {
            name: contract,
            abi: artifacts.abi,
            code: artifacts.codeBoc.toString('base64'),
            init: {
                args: (0, resolveDescriptors_1.getType)(ctx, contract).init.args.map((v) => ({ name: v.name, type: (0, resolveABITypeRef_1.createABITypeRefFromTypeRef)(v.type) })),
                prefix: {
                    bits: 1,
                    value: 0,
                },
                deployment: {
                    kind: 'system-cell',
                    system: systemCell.toBoc().toString('base64')
                },
            },
            compiler: {
                name: 'tact',
                version
            }
        };
        let pkgData = (0, packageCode_1.packageCode)(pkg);
        let pathPkg = path_1.default.resolve(outputPath, project.name + '_' + contract + ".pkg");
        fs_1.default.writeFileSync(pathPkg, pkgData);
        packages.push(pkg);
    }
    // Bindings
    console.log('   > Bindings');
    for (let pkg of packages) {
        console.log('   > ' + pkg.name);
        if (pkg.init.deployment.kind !== 'system-cell') {
            console.warn('   > ' + pkg.name + ': unsupported deployment kind ' + pkg.init.deployment.kind);
            return false;
        }
        try {
            let bindingsServer = (0, writeTypescript_1.writeTypescript)(JSON.parse(pkg.abi), {
                code: pkg.code,
                prefix: pkg.init.prefix,
                system: pkg.init.deployment.system,
                args: pkg.init.args
            });
            fs_1.default.writeFileSync(path_1.default.resolve(outputPath, project.name + '_' + pkg.name + ".ts"), bindingsServer, 'utf-8');
        }
        catch (e) {
            console.warn('Bindings compiler crashed');
            console.warn(e);
            return false;
        }
    }
    // Reports
    console.log('   > Reports');
    for (let pkg of packages) {
        console.log('   > ' + pkg.name);
        try {
            let report = (0, writeReport_1.writeReport)(ctx, pkg);
            let pathBindings = path_1.default.resolve(outputPath, project.name + '_' + pkg.name + ".md");
            fs_1.default.writeFileSync(pathBindings, report, 'utf-8');
        }
        catch (e) {
            console.warn('Report generation crashed');
            console.warn(e);
            return false;
        }
    }
    return true;
}
exports.build = build;
