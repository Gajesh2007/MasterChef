"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.precompile = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const resolveDescriptors_1 = require("../types/resolveDescriptors");
const resolveAllocation_1 = require("../storage/resolveAllocation");
const store_1 = require("../grammar/store");
const resolveStatements_1 = require("../types/resolveStatements");
const grammar_1 = require("../grammar/grammar");
const resolveStrings_1 = require("../types/resolveStrings");
const resolveSignatures_1 = require("../types/resolveSignatures");
function resolveLibraryPath(filePath, name) {
    // Checked collection
    let checked = [];
    // Check stdlib
    if (name.startsWith('@stdlib/')) {
        let p = name.substring('@stdlib/'.length);
        let pp = path_1.default.resolve(__dirname, '..', '..', 'stdlib', 'libs', p + '.tact');
        checked.push(pp);
        if (fs_1.default.existsSync(pp)) {
            return pp;
        }
        else {
            throw Error('Unable to process import ' + name + ' from ' + filePath + ', checked: ' + checked.join(', '));
        }
    }
    // Check relative path
    let t = name;
    if (!t.endsWith('.tact') && !t.endsWith('.fc')) {
        t = t + '.tact';
    }
    let targetPath = path_1.default.resolve(filePath, '..', t);
    checked.push(targetPath);
    if (fs_1.default.existsSync(targetPath)) {
        return targetPath;
    }
    throw Error('Unable to process import ' + name + ' from ' + filePath + ', checked: ' + checked.join(', '));
}
function precompile(ctx, root, sourceFile) {
    // Load stdlib
    const stdlibPath = path_1.default.resolve(__dirname, '../../stdlib/stdlib.tact');
    const stdlib = fs_1.default.readFileSync(stdlibPath, 'utf-8');
    const codePath = path_1.default.resolve(root, sourceFile);
    const code = fs_1.default.readFileSync(codePath, 'utf8');
    //
    // Process imports
    // 
    const imported = [];
    const processed = new Set();
    const funcImports = [];
    const pending = [];
    function processImports(path, source) {
        let imp = (0, grammar_1.parseImports)(source, path);
        for (let i of imp) {
            let resolved = resolveLibraryPath(path, i);
            if (resolved.endsWith('.fc')) {
                if (funcImports.find((v) => v === resolved)) {
                    continue;
                }
                funcImports.push(resolved);
            }
            else {
                if (!processed.has(resolved)) {
                    processed.add(resolved);
                    pending.push(resolved);
                }
            }
        }
    }
    processImports(path_1.default.resolve(__dirname, '..', '..', 'stdlib', 'stdlib.tact'), stdlib);
    processImports(codePath, code);
    while (pending.length > 0) {
        let p = pending.shift();
        let librarySource = fs_1.default.readFileSync(p, 'utf8');
        imported.push({ code: librarySource, path: p });
        processImports(p, librarySource);
    }
    // Load func
    let fc = [];
    for (let i of funcImports) {
        fc.push(fs_1.default.readFileSync(i, 'utf8'));
    }
    // Perform initial compiler steps
    ctx = (0, store_1.openContext)(ctx, [{ code: stdlib, path: stdlibPath }, ...imported, { code, path: codePath }], fc);
    ctx = (0, resolveDescriptors_1.resolveDescriptors)(ctx);
    ctx = (0, resolveSignatures_1.resolveSignatures)(ctx);
    ctx = (0, resolveAllocation_1.resolveAllocations)(ctx);
    ctx = (0, resolveStrings_1.resolveStrings)(ctx);
    ctx = (0, resolveStatements_1.resolveStatements)(ctx);
    // Prepared context
    return ctx;
}
exports.precompile = precompile;
