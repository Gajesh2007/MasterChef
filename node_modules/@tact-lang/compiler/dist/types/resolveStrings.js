"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErrorId = exports.getAllErrors = exports.getStringId = exports.getAllStrings = exports.resolveStrings = void 0;
const ton_crypto_1 = require("ton-crypto");
const context_1 = require("../context");
const ast_1 = require("../grammar/ast");
const resolveConstantValue_1 = require("./resolveConstantValue");
const resolveDescriptors_1 = require("./resolveDescriptors");
let store = (0, context_1.createContextStore)();
let exceptions = (0, context_1.createContextStore)();
function stringId(src) {
    return (0, ton_crypto_1.sha256_sync)(src).readUint32BE(0);
}
function exceptionId(src) {
    return stringId(src) % 63000 + 1000;
}
function resolveStringsInAST(ast, ctx) {
    (0, ast_1.traverse)(ast, (node) => {
        if (node.kind === 'string') {
            if (!store.get(ctx, node.value)) {
                let id = stringId(node.value);
                if (Object.values(store.all(ctx)).find((v) => v.id === id)) {
                    throw new Error(`Duplicate string id: ${node.value}`);
                }
                ctx = store.set(ctx, node.value, { value: node.value, id });
            }
        }
        if (node.kind === 'op_static_call' && node.name === 'require') {
            if (node.args.length !== 2) {
                return;
            }
            let resolved = (0, resolveConstantValue_1.resolveConstantValue)({ kind: 'ref', name: 'String', optional: false }, node.args[1]);
            if (!exceptions.get(ctx, resolved)) {
                let id = exceptionId(resolved);
                if (Object.values(exceptions.all(ctx)).find((v) => v.id === id)) {
                    throw new Error(`Duplicate error id: ${resolved}`);
                }
                ctx = exceptions.set(ctx, resolved, { value: resolved, id });
            }
        }
    });
    return ctx;
}
function resolveStrings(ctx) {
    // Process all static functions
    for (let f of Object.values((0, resolveDescriptors_1.getAllStaticFunctions)(ctx))) {
        ctx = resolveStringsInAST(f.ast, ctx);
    }
    // Process all static constants
    for (let f of Object.values((0, resolveDescriptors_1.getAllStaticConstants)(ctx))) {
        ctx = resolveStringsInAST(f.ast, ctx);
    }
    // Process all types
    for (let t of Object.values((0, resolveDescriptors_1.getAllTypes)(ctx))) {
        // Process fields
        for (const f of Object.values(t.fields)) {
            ctx = resolveStringsInAST(f.ast, ctx);
        }
        // Process constants
        for (const f of Object.values(t.constants)) {
            ctx = resolveStringsInAST(f.ast, ctx);
        }
        // Process init
        if (t.init) {
            ctx = resolveStringsInAST(t.init.ast, ctx);
        }
        // Process receivers
        for (const f of Object.values(t.receivers)) {
            ctx = resolveStringsInAST(f.ast, ctx);
        }
        // Process functions
        for (let f of t.functions.values()) {
            ctx = resolveStringsInAST(f.ast, ctx);
        }
    }
    return ctx;
}
exports.resolveStrings = resolveStrings;
function getAllStrings(ctx) {
    return Object.values(store.all(ctx));
}
exports.getAllStrings = getAllStrings;
function getStringId(value, ctx) {
    let ex = store.get(ctx, value);
    if (!ex) {
        throw new Error(`String not found: ${value}`);
    }
    return ex.id;
}
exports.getStringId = getStringId;
function getAllErrors(ctx) {
    return Object.values(exceptions.all(ctx));
}
exports.getAllErrors = getAllErrors;
function getErrorId(value, ctx) {
    let ex = exceptions.get(ctx, value);
    if (!ex) {
        throw new Error(`Error not found: ${value}`);
    }
    return ex.id;
}
exports.getErrorId = getErrorId;
