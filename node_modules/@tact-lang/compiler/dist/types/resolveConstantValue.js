"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveConstantValue = void 0;
const ton_core_1 = require("ton-core");
const ast_1 = require("../grammar/ast");
const types_1 = require("./types");
function reduceInt(ast) {
    if (ast.kind === 'number') {
        return ast.value;
    }
    else if (ast.kind === 'op_binary') {
        let l = reduceInt(ast.left);
        let r = reduceInt(ast.right);
        if (ast.op === '+') {
            return l + r;
        }
        else if (ast.op === '-') {
            return l - r;
        }
        else if (ast.op === '*') {
            return l * r;
        }
        else if (ast.op === '/') {
            return l / r;
        }
        else if (ast.op === '%') {
            return l % r;
        }
    }
    else if (ast.kind === 'op_unary') {
        if (ast.op === '-') {
            return -reduceInt(ast.right);
        }
        else if (ast.op === '+') {
            return reduceInt(ast.right);
        }
    }
    else if (ast.kind === 'op_static_call') {
        if (ast.name === 'ton') {
            if (ast.args.length === 1) {
                return BigInt((0, ton_core_1.toNano)(reduceString(ast.args[0])).toString(10));
            }
        }
    }
    (0, ast_1.throwError)('Cannot reduce expression to integer', ast.ref);
}
function reduceBool(ast) {
    if (ast.kind === 'boolean') {
        return ast.value;
    }
    if (ast.kind === 'op_unary') {
        if (ast.op === '!') {
            return !reduceBool(ast.right);
        }
    }
    if (ast.kind === 'op_binary') {
        if (ast.op === '&&') {
            return reduceBool(ast.left) && reduceBool(ast.right);
        }
        else if (ast.op === '||') {
            return reduceBool(ast.left) || reduceBool(ast.right);
        }
        // TODO: More cases
    }
    (0, ast_1.throwError)('Cannot reduce expression to boolean', ast.ref);
}
function reduceString(ast) {
    if (ast.kind === 'string') {
        return ast.value;
    }
    (0, ast_1.throwError)('Cannot reduce expression to string', ast.ref);
}
function resolveConstantValue(type, ast) {
    if (type.kind !== 'ref') {
        (0, ast_1.throwError)(`Expected constant value, got ${(0, types_1.printTypeRef)(type)}`, ast.ref);
    }
    // Handle optional
    if (type.optional) {
        if (ast.kind === 'null') {
            return null;
        }
    }
    // Handle int
    if (type.name === 'Int') {
        return reduceInt(ast);
    }
    // Handle bool
    if (type.name === 'Bool') {
        return reduceBool(ast);
    }
    // Handle string
    if (type.name === 'String') {
        return reduceString(ast);
    }
    (0, ast_1.throwError)(`Expected constant value, got ${(0, types_1.printTypeRef)(type)}`, ast.ref);
}
exports.resolveConstantValue = resolveConstantValue;
